/**
 * @fileoverview Firestore Security Rules for AgriVaani.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for farmer-specific data,
 * while allowing public read access to certain collections like weather forecasts and learning articles.
 * It leverages path-based authorization and data denormalization to optimize security and performance.
 *
 * Data Structure:
 * - /farmers/{farmerId}: Farmer profiles, where {farmerId} corresponds to the Firebase Auth UID.
 * - /farmers/{farmerId}/transactions/{transactionId}: Financial transactions for a specific farmer.
 * - /farmers/{farmerId}/cultivationGuides/{guideId}: Cultivation guides specific to a farmer.
 * - /farms/{farmId}: Farm data, with a 'farmerId' field indicating ownership.
 * - /weather_forecasts/{weatherForecastId}: Publicly readable weather forecast data.
 * - /learning_articles/{learningArticleId}: Publicly readable learning articles.
 * - /roles_admin/{uid}: Collection to denote admin status.
 * - /forumPosts/{postId}: Community forum posts.
 *
 * Key Security Decisions:
 * - Farmers can only access their own profile data, transactions, and cultivation guides.
 * - Farms include a 'farmerId' field to determine ownership, allowing listing of a farmer's farms.
 * - Weather forecasts and learning articles are publicly readable.
 * - Only users with a document in /roles_admin/{uid} are considered admins.
 * - Data validation is minimized to facilitate rapid prototyping but focuses on ownership and relational integrity.
 * - The `likes` subcollection within `forumPosts` is not implemented in this ruleset as the client must create documents within /forumPosts/{postId}/likes/{likeId} to signify a like, rather than incrementing a `likes` field on the parent document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // Farmers Collection
    /**
     * @description Manages farmer profiles. Only the authenticated farmer can read and write their own profile.
     * @path /farmers/{farmerId}
     * @allow (create) Signed-in user creates their own profile with matching UID.
     * @deny (create) User attempts to create a profile with a mismatched UID.
     * @allow (get, update, delete) Signed-in user accesses their own profile.
     * @deny (get, update, delete) User attempts to access another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /farmers/{farmerId} {
      allow get: if isOwner(farmerId);
      allow list: if false;
      allow create: if isOwner(farmerId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(farmerId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Manages financial transactions for a specific farmer. Only the owner can read/write.
     * @path /farmers/{farmerId}/transactions/{transactionId}
     * @allow (create) Signed-in user creates a transaction under their own profile.
     * @deny (create) User attempts to create a transaction under another user's profile.
     * @allow (get, update, delete) Signed-in user accesses their own transactions.
     * @deny (get, update, delete) User attempts to access another user's transactions.
     * @principle Enforces document ownership for all operations.
     */
    match /farmers/{farmerId}/transactions/{transactionId} {
      allow get: if isOwner(farmerId);
      allow list: if isOwner(farmerId);
      allow create: if isOwner(farmerId);
      allow update: if isExistingOwner(farmerId);
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Manages cultivation guides for a specific farmer. Only the owner can read/write.
     * @path /farmers/{farmerId}/cultivationGuides/{guideId}
     * @allow (create) Signed-in user creates a guide under their own profile.
     * @deny (create) User attempts to create a guide under another user's profile.
     * @allow (get, update, delete) Signed-in user accesses their own guides.
     * @deny (get, update, delete) User attempts to access another user's guides.
     * @principle Enforces document ownership for all operations.
     */
    match /farmers/{farmerId}/cultivationGuides/{guideId} {
      allow get: if isOwner(farmerId);
      allow list: if isOwner(farmerId);
      allow create: if isOwner(farmerId) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(farmerId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Manages farm data. Includes 'farmerId' to indicate ownership.
     * @path /farms/{farmId}
     * @allow (create) Signed-in user creates a farm with their UID as farmerId.
     * @deny (create) User attempts to create a farm with a mismatched farmerId.
     * @allow (get, list, update, delete) Signed-in user accesses their own farms.
     * @deny (get, list, update, delete) User attempts to access another user's farms.
     * @principle Enforces document ownership using the 'farmerId' field.
     */
    match /farms/{farmId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.farmerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.farmerId == request.auth.uid;
      allow delete: if isExistingOwner(resource.data.farmerId);
    }

    /**
     * @description Manages weather forecast data. Publicly readable.
     * @path /weather_forecasts/{weatherForecastId}
     * @allow (get, list) Anyone can read weather forecasts.
     * @deny (create, update, delete) No one can create, update, or delete weather forecasts through the client.
     * @principle Allows public read access while restricting write access.
     */
    match /weather_forecasts/{weatherForecastId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages learning articles. Publicly readable.
     * @path /learning_articles/{learningArticleId}
     * @allow (get, list) Anyone can read learning articles.
     * @deny (create, update, delete) No one can create, update, or delete learning articles through the client.
     * @principle Allows public read access while restricting write access.
     */
    match /learning_articles/{learningArticleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Collection to store admin roles.  Existence of document determines admin status.
     * @path /roles_admin/{uid}
     * @allow (get) Admins can read their own role.
     * @deny (list) No listing allowed.
     * @allow (create) Only accessible from backend.
     * @principle Restricts direct client access to admin roles.
     */
    match /roles_admin/{uid} {
        allow get: if isAdmin();
        allow list: if false;
        allow create, update, delete: if false; // Only writeable by backend functions
    }

    /**
     * @description Manages community forum posts.
     * @path /forumPosts/{postId}
     * @allow (create) Signed-in user can create a post.
     * @allow (get, list) Anyone can read forum posts.
     * @allow (update, delete) Only the author can update or delete their post.
     * @principle Allows public read access with owner-only writes.
     */
    match /forumPosts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }
  }
}