/**
 * @fileOverview Firestore Security Rules for the AgriVaani application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data while allowing public read access to certain collections like weather forecasts and learning articles.
 * Farm data is secured based on the farmerId within the Farm document.
 * Forum posts and comments allow open read access and owner-based modification.
 * Chats and ChatMessages follow a closed collaborator model based on participant lists.
 *
 * Data Structure:
 * - /farmers/{farmerId}: Stores farmer profiles, where farmerId is the Firebase Auth UID.
 * - /farmers/{farmerId}/transactions/{transactionId}: Stores transactions for each farmer.
 * - /farmers/{farmerId}/cultivationGuides/{guideId}: Stores AI cultivation guides for each farmer.
 * - /farms/{farmId}: Stores farm data, including a farmerId field.
 * - /weather_forecasts/{weatherForecastId}: Stores public weather forecast data.
 * - /learning_articles/{learningArticleId}: Stores public learning articles.
 * - /roles_admin/{uid}: Collection to store admin roles (document existence grants admin status).
 * - /forumPosts/{postId}: Stores forum posts.
 * - /forumPosts/{postId}/comments/{commentId}: Stores comments on forum posts.
 * - /forumPosts/{postId}/comments/{commentId}/replies/{replyId}: Stores replies to comments.
 * - /chats/{chatId}: Stores chat metadata, including participant lists.
 * - /chats/{chatId}/messages/{messageId}: Stores chat messages.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed unless explicitly required and secured.
 * - Weather forecasts and learning articles are publicly readable.
 * - For forum posts and comments, all reads are public, but modifications are restricted to the owner.
 * - The `/roles_admin/{uid}` collection grants admin access based on document existence. This collection is not directly modifiable through the client. Admin status should be granted via backend functions.
 * - Chats and ChatMessages are secured using a closed collaborator model.
 *
 * Denormalization for Authorization:
 * - The `Farm` entity contains a `farmerId` field, enabling direct ownership checks without additional `get()` calls.
 * - The `Chat` entity contains a `participants` array to authorize access to the chat and its messages.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows a farmer to manage their own profile.
     * @path /farmers/{farmerId}
     * @allow (create) If the user is signed in and the farmerId matches the authenticated user's UID.
     * @allow (get, list, update, delete) If the farmerId matches the authenticated user's UID.
     * @deny (create) If the farmerId does not match the authenticated user's UID.
     * @principle Enforces document ownership for farmer profiles.
     */
    match /farmers/{farmerId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if false;
      allow create: if isOwner(farmerId);
      allow update: if isExistingOwner(farmerId);
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Allows a farmer to manage their own transactions.
     * @path /farmers/{farmerId}/transactions/{transactionId}
     * @allow (create) If the farmerId matches the authenticated user's UID.
     * @allow (get, list, update, delete) If the farmerId matches the authenticated user's UID.
     * @deny (create) If the farmerId does not match the authenticated user's UID.
     * @principle Enforces document ownership for farmer transactions.
     */
    match /farmers/{farmerId}/transactions/{transactionId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get, list: if isOwner(farmerId);
      allow create: if isOwner(farmerId);
      allow update: if isExistingOwner(farmerId);
      allow delete: if isExistingOwner(farmerId);
    }

     /**
      * @description Allows a farmer to manage their own cultivation guides.
      * @path /farmers/{farmerId}/cultivationGuides/{guideId}
      * @allow (create) If the farmerId matches the authenticated user's UID.
      * @allow (get, list, update, delete) If the farmerId matches the authenticated user's UID.
      * @deny (create) If the farmerId does not match the authenticated user's UID.
      * @principle Enforces document ownership for cultivation guides.
      */
    match /farmers/{farmerId}/cultivationGuides/{guideId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(farmerId);
      allow create: if isOwner(farmerId);
      allow update: if isExistingOwner(farmerId);
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Allows read access to all Farms and restricts write access to the owner of the farm.
     * @path /farms/{farmId}
     * @allow (get, list) If true (public read).
     * @allow (create) If the request.auth.uid matches the farmerId in the incoming data.
     * @allow (update, delete) If the request.auth.uid matches the farmerId in the existing document.
     * @deny (create) If the request.auth.uid does not match the farmerId in the incoming data.
     * @deny (update, delete) If the request.auth.uid does not match the farmerId in the existing document.
     * @principle Public read with owner-only writes; enforces document ownership for writes.
     */
    match /farms/{farmId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(farmerId) {
        return isSignedIn() && request.auth.uid == farmerId;
      }

      function isExistingOwner(farmerId) {
        return isOwner(farmerId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.farmerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.farmerId);
      allow delete: if isExistingOwner(resource.data.farmerId);
    }

    /**
     * @description Allows public read access to weather forecasts.
     * @path /weather_forecasts/{weatherForecastId}
     * @allow (get, list) If true (public read).
     * @deny (create, update, delete) Always deny writes (data should be managed by a trusted source).
     * @principle Public read, no writes allowed.
     */
    match /weather_forecasts/{weatherForecastId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to learning articles.
     * @path /learning_articles/{learningArticleId}
     * @allow (get, list) If true (public read).
     * @deny (create, update, delete) Always deny writes (data should be managed by a trusted source).
     * @principle Public read, no writes allowed.
     */
    match /learning_articles/{learningArticleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Collection to store admin roles.  Existence of document determines admin status.
     * @path /roles_admin/{uid}
     * @allow (get) If true (allows checking for admin status).
     * @deny (list, create, update, delete) All other operations are denied.  Admin status should only be granted via backend functions.
     * @principle Checks for admin role
     */
     match /roles_admin/{uid} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isAdmin() {
            return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
        }

        allow get: if isSignedIn() && isAdmin();
        allow list, create, update, delete: if false;
     }

      /**
       * @description Allows public read access to forum posts, and restricts write access to the author.
       * @path /forumPosts/{postId}
       * @allow (get, list) If true (public read).
       * @allow (create) If the authorId matches the authenticated user's UID.
       * @allow (update, delete) If the authorId matches the authenticated user's UID in the existing document.
       * @deny (create) If the authorId does not match the authenticated user's UID.
       * @deny (update, delete) If the authorId does not match the authenticated user's UID in the existing document.
       * @principle Public read with owner-only writes; enforces document ownership for writes.
       */
      match /forumPosts/{postId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isOwner(authorId) {
            return isSignedIn() && request.auth.uid == authorId;
        }

        function isExistingOwner(authorId) {
          return isOwner(authorId) && resource != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
      }

      /**
       * @description Allows public read access to comments, and restricts write access to the author.
       * @path /forumPosts/{postId}/comments/{commentId}
       * @allow (get, list) If true (public read).
       * @allow (create) If the authorId matches the authenticated user's UID.
       * @allow (update, delete) If the authorId matches the authenticated user's UID in the existing document.
       * @deny (create) If the authorId does not match the authenticated user's UID.
       * @deny (update, delete) If the authorId does not match the authenticated user's UID in the existing document.
       * @principle Public read with owner-only writes; enforces document ownership for writes.
       */
      match /forumPosts/{postId}/comments/{commentId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isOwner(authorId) {
            return isSignedIn() && request.auth.uid == authorId;
        }

        function isExistingOwner(authorId) {
          return isOwner(authorId) && resource != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
      }

    /**
     * @description Allows public read access to replies, and restricts write access to the author.
     * @path /forumPosts/{postId}/comments/{commentId}/replies/{replyId}
     * @allow (get, list) If true (public read).
     * @allow (create) If the authorId matches the authenticated user's UID.
     * @allow (update, delete) If the authorId matches the authenticated user's UID in the existing document.
     * @deny (create) If the authorId does not match the authenticated user's UID.
     * @deny (update, delete) If the authorId does not match the authenticated user's UID in the existing document.
     * @principle Public read with owner-only writes; enforces document ownership for writes.
     */
      match /forumPosts/{postId}/comments/{commentId}/replies/{replyId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isOwner(authorId) {
            return isSignedIn() && request.auth.uid == authorId;
        }

        function isExistingOwner(authorId) {
          return isOwner(authorId) && resource != null;
        }

        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
      }

    /**
     * @description Allows access to chats for participants only.
     * @path /chats/{chatId}
     * @allow (get, list) If the user is a participant in the chat.
     * @allow (create, update) If the user is a participant in the chat and can manage participants.
     * @deny (create, update) If the user is not a participant in the chat.
     * @allow (delete) If false (deletion not permitted via client).
     * @principle Enforces shared access based on the participants list.
     */
    match /chats/{chatId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isParticipant() {
            return isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
        }

        function canManageParticipants() {
            // Adjust the logic based on your application's participant management rules.
            // This example allows any participant to update the chat.
            return isParticipant();
        }

        allow get, list: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
        allow create: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
        allow update: if isSignedIn() && canManageParticipants();
        allow delete: if false; // Prevent client-side deletion
    }

    /**
     * @description Allows access to chat messages for participants of the parent chat only.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) If the user is a participant in the chat.
     * @allow (create) If the user is a participant in the chat and the senderId matches the authenticated user's UID.
     * @deny (create) If the user is not a participant in the chat or the senderId does not match the authenticated user's UID.
     * @deny (update, delete) Always deny updates and deletes (messages are immutable).
     * @principle Enforces shared access based on the participants list in the parent chat.
     */
    match /chats/{chatId}/messages/{messageId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isParticipant() {
            return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        }

        allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        allow create: if isSignedIn() && isParticipant() && request.resource.data.senderId == request.auth.uid;
        allow update, delete: if false; // Messages are immutable
    }
  }
}