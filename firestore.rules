/**
 * @fileOverview Firestore Security Rules for AgriVaani.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for farmer-related data,
 * while allowing public read access to certain collections like weather forecasts and learning articles.
 * It leverages path-based authorization and data denormalization to ensure efficient and secure access control.
 *
 * Data Structure:
 * - /farmers/{farmerId}: Farmer profiles, where farmerId matches the Firebase Auth UID.
 * - /farmers/{farmerId}/transactions/{transactionId}: Financial transactions owned by a specific farmer.
 * - /farmers/{farmerId}/cultivationGuides/{guideId}: AI-generated cultivation guides owned by a specific farmer.
 * - /farms/{farmId}: Farm data, with a 'farmerId' field indicating ownership.
 * - /weather_forecasts/{weatherForecastId}: Publicly readable weather forecast data.
 * - /learning_articles/{learningArticleId}: Publicly readable learning articles.
 * - /roles_admin/{uid}: Collection for storing admin roles; document existence grants admin status.
 * - /forumPosts/{postId}: Community forum posts.
 * - /forumPosts/{postId}/comments: Comments for a specific forum post.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed for privacy.
 * - Public read access is granted to weather forecasts and learning articles.
 * - Ambiguous relationships default to strict owner-only access.
 * - Admin roles are managed through a dedicated collection.
 *
 * Denormalization for Authorization:
 * - The 'Farm' entity includes a 'farmerId' field, allowing for efficient filtering of farms owned by a specific user.
 *
 * Structural Segregation:
 * - Private farmer data (transactions, cultivation guides) is stored under the /farmers/{farmerId} path,
 *   while public data (weather forecasts, learning articles) is stored in separate top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to farmer profiles. Only the owner can read/write their own profile.
     * @path /farmers/{farmerId}
     * @allow (create) User with UID 'farmer123' can create a farmer document where farmerId == 'farmer123'.
     * @deny (create) User with UID 'farmer456' cannot create a farmer document where farmerId == 'farmer123'.
     * @allow (get, update, delete) User with UID 'farmer123' can read/update/delete their own profile (farmerId == 'farmer123').
     * @deny (get, update, delete) User with UID 'farmer456' cannot read/update/delete the profile of user 'farmer123'.
     * @principle Enforces document ownership for writes and restricts read access to the owner.
     */
    match /farmers/{farmerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(farmerId);
      allow list: if false;
      allow create: if request.auth != null && request.auth.uid == farmerId;
      allow update: if isOwner(farmerId);
      allow delete: if isOwner(farmerId);
    }

    /**
     * @description Allows access to financial transactions for a specific farmer. Only the owner can read/write.
     * @path /farmers/{farmerId}/transactions/{transactionId}
     * @allow (create) User with UID 'farmer123' can create a transaction under their profile (farmerId == 'farmer123').
     * @deny (create) User with UID 'farmer456' cannot create a transaction under the profile of user 'farmer123'.
     * @allow (get, update, delete) User with UID 'farmer123' can read/update/delete their own transactions (farmerId == 'farmer123').
     * @deny (get, update, delete) User with UID 'farmer456' cannot read/update/delete transactions of user 'farmer123'.
     * @principle Enforces document ownership for writes and restricts read access to the owner.
     */
    match /farmers/{farmerId}/transactions/{transactionId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(farmerId);
      allow list: if false;
      allow create: if isOwner(farmerId);
      allow update: if isOwner(farmerId);
      allow delete: if isOwner(farmerId);
    }

    /**
     * @description Allows access to cultivation guides for a specific farmer. Only the owner can read/write.
     * @path /farmers/{farmerId}/cultivationGuides/{guideId}
     * @allow (create) User with UID 'farmer123' can create a cultivation guide under their profile (farmerId == 'farmer123').
     * @deny (create) User with UID 'farmer456' cannot create a cultivation guide under the profile of user 'farmer123'.
     * @allow (get, update, delete) User with UID 'farmer123' can read/update/delete their own cultivation guides (farmerId == 'farmer123').
     * @deny (get, update, delete) User with UID 'farmer456' cannot read/update/delete cultivation guides of user 'farmer123'.
     * @principle Enforces document ownership for writes and restricts read access to the owner.
     */
    match /farmers/{farmerId}/cultivationGuides/{guideId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(farmerId);
      allow list: if false;
      allow create: if isOwner(farmerId);
      allow update: if isOwner(farmerId);
      allow delete: if isOwner(farmerId);
    }

    /**
     * @description Allows access to farm data. Only the owner (farmerId) can create/update/delete.  Anyone can read.
     * @path /farms/{farmId}
     * @allow (get, list) Any user can read farm data.
     * @allow (create) User with UID 'farmer123' can create a farm document with farmerId == 'farmer123'.
     * @deny (create) User with UID 'farmer456' cannot create a farm document with farmerId == 'farmer123'.
     * @allow (update, delete) User with UID 'farmer123' can update/delete a farm document where farmerId == 'farmer123'.
     * @deny (update, delete) User with UID 'farmer456' cannot update/delete a farm document where farmerId == 'farmer123'.
     * @principle Public read access with owner-only writes, enforcing ownership via the 'farmerId' field.
     */
    match /farms/{farmId} {
      function isOwner(farmerId) {
        return request.auth != null && request.auth.uid == farmerId;
      }
      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.farmerId == request.auth.uid;
      allow update: if request.auth != null && request.resource.data.farmerId == request.auth.uid;
      allow delete: if request.auth != null && request.resource.data.farmerId == request.auth.uid;
    }

    /**
     * @description Allows public read access to weather forecast data. No write access is allowed via rules.
     * @path /weather_forecasts/{weatherForecastId}
     * @allow (get, list) Any user can read weather forecast data.
     * @deny (create, update, delete) No user can create/update/delete weather forecast data via client-side rules.
     * @principle Public read-only access. Write operations should be handled by a trusted environment.
     */
    match /weather_forecasts/{weatherForecastId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to learning articles. No write access is allowed via rules.
     * @path /learning_articles/{learningArticleId}
     * @allow (get, list) Any user can read learning articles.
     * @deny (create, update, delete) No user can create/update/delete learning articles via client-side rules.
     * @principle Public read-only access. Write operations should be handled by a trusted environment.
     */
    match /learning_articles/{learningArticleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
        /**
         * @description Allows admins to be created and read. Access is restricted to admins only.
         * @path /roles_admin/{uid}
         */
    match /roles_admin/{uid} {
        function isAdmin() {
            return get(/databases/$(database)/documents/roles_admin/$(request.auth.uid)).data.uid == request.auth.uid;
        }

        allow get: if exists(/databases/$(database)/documents/roles_admin/$(uid));
        allow list: if false;
        allow create: if request.auth != null && request.auth.uid == uid;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Allows read access to all forum posts. Only the author can update/delete.
     * @path /forumPosts/{postId}
     * @allow (get, list) Any user can read forum posts.
     * @allow (create) User with UID 'user123' can create a forum post.
     * @deny (create) User with UID 'user456' cannot create a forum post with authorId different than their uid.
     * @allow (update, delete) User with UID 'user123' can update/delete their own forum post (authorId == 'user123').
     * @deny (update, delete) User with UID 'user456' cannot update/delete the forum post of user 'user123'.
     * @principle Public read access with owner-only writes, enforcing ownership via the 'authorId' field.
     */
    match /forumPosts/{postId} {
      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow delete: if request.auth != null && request.resource.data.authorId == request.auth.uid;

      /**
       * @description Allows access to comments for a specific forum post. Only the author of the comment can create a comment
       * @path /forumPosts/{postId}/comments
       * @allow (create) User with UID 'user123' can create a comment.
       * @deny (create) User with UID 'user456' cannot create a comment with authorId different than their uid.
       */
        match /comments/{commentId} {
          allow get: if true;
          allow list: if true;
          allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
          allow update: if request.auth != null && request.resource.data.authorId == request.auth.uid;
          allow delete: if request.auth != null && request.resource.data.authorId == request.auth.uid;
        }
    }
  }
}